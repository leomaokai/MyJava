# 逻辑架构

`mysql`可分为server层和存储引擎层两部分

server层包括**连接器**,**查询缓冲**,**分析器**,**优化器**,**执行器**等,涵盖了`mysql`的大多数**核心服务**功能,以及所有的**内置函数**,所有的**跨存储引擎的功能**都在这一层实现,比如存储过程,触发器,视图等.

存储引擎负责数据的存储和提取,默认存储引擎时`InnoDB`

## 连接器

连接器负责跟客户端建立连接,获取权限,维持和管理连接

```
连接命令:
mysql -h$ip -P$port -u$user -p
输入密码
查看连接状态:
show processlist;
```

**长连接**是指连接成功后,如果客户端持续有请求,则一直使用同一个连接,**短连接**则是指每次执行完很少的几次查询就断开连接,下次查询再重新建立一个.建立连接的过程通常是比较复杂的,应该尽量减少建立连接的动作.

解决长连接内存占用太大问题?

* 定期断开长连接
* 执行`mysql_reset_connection`重新初始化连接资源

## 查询缓存

`mysql`拿到一个查询请求后,会先到查询缓存中查询之前是否执行过该语句,之前执行的语句及其结果可能会以key-value对形式被缓存到内存中.key是查询的语句,value是查询的结果,如果可以再缓存中找到key,则value直接返回给客户端,如果语句不再查询缓存中,则继续后面的执行阶段,执行完成后会被存入查询缓存中

但是大多数情况下不要使用查询缓存,因为查询缓存往往利大于弊

因为查询缓存的失效非常频繁,每次对表进行更新,查询缓存即失效

将`query_cache_type`设置成`DEMAND`即默认不使用查询缓存

而`mysql8.0`直接将查询缓存功能删除了

## 分析器

分析器对sql语句做解析

对于一条有多个字符串和空格组成的sql语句,mysql需要识别出里面的字符串分别是什么,代表什么

语法识别完成后,分析器会根据语法规定来判断输入的sql语句是否满足sql语法,若语法错误,则输出错误提醒

## 优化器

优化器对执行方案进行优化

通常一条语句会有多种执行方法,虽然逻辑结果是一样的,但是执行效率会有不同,而优化器的作用就是决定选择使用哪种方案

## 执行器

执行器开始执行语句

开始执行时,先判断执行查询的权限,如果没有权限则返回错误

然后执行器会根据表的引擎定义,去使用这个引擎提供的接口

执行流程:

* 调用`InnoDB`引擎接口取这个表的第一行,判断查询条件是否满足,如果满足则将这行存在结果集中,否则跳过
* 调用引擎接口取下一行,重复相同的判断逻辑,直到取到这个表的最后一行
* 执行器将上述遍历过程中所有满足条件的行组成记录集作为结果集返回给客户端

至此,语句执行完成

# 日志系统

当执行一条数据更新语句时,会涉及两个重要的日志模块

`redo log`重做日志    `binlog`归档日志

## redo log:

当有一条记录需要更新时,`InnoDB`引擎就会先把记录写到`redo log`里面,并更新内存,同时,`InnoDB`引擎会在适当时,将这个操作记录更新到磁盘里面(系统比较空闲时)

`redo log`是固定大小的,类似于一个循环列表,比如可以配置为一组4个文件,每个文件的大小是1GB,那么它就可以记录4GB的操作.从头开始写,写满后要把记录更新到数据文件,然后擦除一些记录,再循环写

有了`redo log`,`InnoDB`就可以保证即使数据库发生异常重启,之前提交的记录都不会丢失,这个能力称为`crash-safe`

## binlog:

`rode log`是`InnoDB`引擎特有的日志,而Server层也有自己的日志,称为`binlog`(归档日志)

两种日志的不同点:

* `redo log`是`InnoDB`引擎特有的,而`binlog`是`MySQL`的server层实现的,所有引擎都可以使用
* `redo log`是物理日志,记录的是"在某个数据页上做了什么修改",而`binlog`是逻辑日志,记录的是这个语句的原始逻辑
* `redo log`是循环写的,空间固定会用完,而`binlog`是可以追加写的,追加写是指`binlog`文件写到一定大小后会切换到下一个,并不会覆盖以前的日志

## 两阶段提交

redo log的写入拆成两个步骤:prepare和commit

`binlog`的写入在redo log写入的两个步骤之间

redo log和`binlog`都可以用于表示事务的提交状态,而两阶段提交就是让这两个状态保持逻辑上的一致

# 事务

事务就是要保证一组数据库操作要么全部成功,要么全部失败

`MySQL`中事务支持是引擎层实现

事务的标准特征ACID:

原子性(Atomicity):一个事务必须被视为一个不可分割的最小工作单元,整个事务中的所有操作要么全部提交成功,要么全部失败回滚

一致性(Consistency):数据库总是从一个一致性的状态转换到另一个一致性的状态

隔离性(Isolation):一个事务所做的修改在最终提交以前,对其他事务是不可见的

持久性(Durability):一旦事务提交,则其所做的修改就会永久保存到数据库中,即使系统崩溃,修改的数据也不会丢失

## 隔离级别

`SQL`标准事务隔离级别包括:

* 读未提交(`read uncommitted`):一个事务还没提交时,它做的变更就能被别的事务看到
* 读提交(`read committed`):一个事务提交之后,它做的变更才能被其它事务看到
* 可重复读(`repeatable read`):一个事务执行过程中看到的数据,总是跟这个事务在启动时看到数据是一致的,未提交变更对其它事务也是不可见的
* 串行化(`serializable`):对一行记录,写会加写锁,读会加读锁,当出现读写锁冲突时,后访问的事务必须等前一个事务执行完成,才能继续执行

`show variables like 'transaction_isolation'`查看隔离级别

在实现上,数据库里面会创建一个视图,访问的时候以视图的逻辑结果为准

在"可重复读"的隔离级别下,这个视图是在事务启动时创建的,整个事务存在期间都会用这个视图

在"读提交"的隔离级别下,这个视图是在每个`SQL`语句开始执行的时候创建的

"读未提交"隔离级别下直接返回记录上的最新值,没有视图概念

"串行化"隔离级别直接用加锁的方式来避免并行访问

## 事务隔离的实现

"可重复读"说明:

在`MySQL`中,实际上每条记录在更新的时候都会同时记录一条回滚操作,记录上的最新值,通过回滚操作,都可以得到前一个状态的值

只有当没有事务再需要用这些回滚日志时,回滚日志才会被删除

长事务意味着系统里面存放了很老的事务视图,由于这些事务随时可能访问数据库里面的任何数据,所以这个事务提交之前,数据库里面它可能用到的回滚记录必须保留,这会导致大量占用存储空间,此外,长事务还占用锁资源,也可能拖垮整个库,所以尽量不要使用长事务

## 事务的启动方式

`MySQL`的事务启动有以下几种:

* 显示启动事务语句,`begin`或`start transaction`,提交语句`commit`,回滚语句`rollback`
* `set autocommit=0`,这个命令会将这个线程的自动提交关闭,如果只执行一条select语句,这个事务就启动了,而且并不会自动提交.这个事务持续存在直到主动执行commit或rollback语句,或者断开连接

有些客户端连接框架会默认连接成功后执行一个`set autocommit=0`的命令,这会导致接下来的查询都会再事务中,如果是长连接,就导致了意外的长事务

使用要使用`set autocommit=1`,通过显示语句的方式来启动事务

再`autocommit=1`的情况下,用begin显示启动事务,如果执行commit则提交事务,如果执行`commit work and chain`,则会提交事务并自动启动下一个事务,这样就省去了再次执行begin语句的开销

在`information_schema`库的`innodb_trx`这个表中查询长事务

```sql
--查找持续时间超过60s的事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```

